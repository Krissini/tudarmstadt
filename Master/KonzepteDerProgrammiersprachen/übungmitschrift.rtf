{\rtf1\ansi\deff3\adeflang1025
{\fonttbl{\f0\froman\fprq2\fcharset0 Times New Roman;}{\f1\froman\fprq2\fcharset2 Symbol;}{\f2\fswiss\fprq2\fcharset0 Arial;}{\f3\fswiss\fprq0\fcharset0 Calibri;}{\f4\fnil\fprq2\fcharset0 Microsoft YaHei;}{\f5\fnil\fprq2\fcharset0 Arial Unicode MS;}{\f6\fswiss\fprq0\fcharset128 Arial Unicode MS;}}
{\colortbl;\red0\green0\blue0;\red128\green128\blue128;}
{\stylesheet{\s0\snext0\nowidctlpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf0\hich\af3\langfe1031\dbch\af3\afs24\lang1031\loch\f3\fs24\lang1031 Standard;}
{\s15\sbasedon0\snext16\sb240\sa120\keepn\hich\af4\dbch\af5\afs28\loch\f2\fs28 Überschrift;}
{\s16\sbasedon0\snext16\sb0\sa120 Textkörper;}
{\s17\sbasedon16\snext17\sb0\sa120\dbch\af6 Liste;}
{\s18\sbasedon0\snext18\sb120\sa120\noline\i\dbch\af6\afs24\ai\fs24 Beschriftung;}
{\s19\sbasedon0\snext19\noline\dbch\af6 Verzeichnis;}
}{\info{\creatim\yr0\mo0\dy0\hr0\min0}{\revtim\yr0\mo0\dy0\hr0\min0}{\printim\yr0\mo0\dy0\hr0\min0}{\comment OpenOffice}{\vern4140}}\deftab720\deftab720\deftab720\deftab720\deftab720\deftab720\deftab720\deftab720\deftab720\deftab720\deftab720\deftab720\deftab720\deftab720\deftab720\deftab720\deftab720\deftab720\deftab720\deftab720

{\*\pgdsctbl
{\pgdsc0\pgdscuse195\pgwsxn12240\pghsxn15840\marglsxn1800\margrsxn1800\margtsxn1440\margbsxn1440\pgdscnxt0 Standard;}}
\formshade{\*\pgdscno0}\paperh15840\paperw12240\margl1800\margr1800\margt1440\margb1440\sectd\sbknone\sectunlocked1\pgndec\pgwsxn12240\pghsxn15840\marglsxn1800\margrsxn1800\margtsxn1440\margbsxn1440\ftnbj\ftnstart1\ftnrstcont\ftnnar\aenddoc\aftnrstcont\aftnstart1\aftnnrlc
\pgndec\pard\plain \s0\nowidctlpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf0\hich\af3\langfe1031\dbch\af3\afs24\lang1031\loch\f3\fs24\lang1031\sl276\slmult1\sb0\sa200{\afs22\rtlch \ltrch\loch\fs22\lang7
lamda calculus}
\par \pard\plain \s0\nowidctlpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf0\hich\af3\langfe1031\dbch\af3\afs24\lang1031\loch\f3\fs24\lang1031\sl276\slmult1\sb0\sa200{\afs22\rtlch \ltrch\loch\fs22\lang7
Symbol = identifier = e ::= x\tab }
\par \pard\plain \s0\nowidctlpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf0\hich\af3\langfe1031\dbch\af3\afs24\lang1031\loch\f3\fs24\lang1031\sl276\slmult1\sb0\sa200{\afs22\rtlch \ltrch\loch\fs22\lang7
Fun = function definition = abstraction = lamda x * e |mit x = parameter, e = function body}
\par \pard\plain \s0\nowidctlpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf0\hich\af3\langfe1031\dbch\af3\afs24\lang1031\loch\f3\fs24\lang1031\sl276\slmult1\sb0\sa200{\afs22\rtlch \ltrch\loch\fs22\lang7
App = function call = application = e e}
\par \pard\plain \s0\nowidctlpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf0\hich\af3\langfe1031\dbch\af3\afs24\lang1031\loch\f3\fs24\lang1031\sl276\slmult1\sb0\sa200{\afs22\rtlch \ltrch\loch\fs22\lang7
example of lamda/anonymous: lamda x * (x times x) equals normal function doSquare(int x)\{return x times x\}}
\par \pard\plain \s0\nowidctlpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf0\hich\af3\langfe1031\dbch\af3\afs24\lang1031\loch\f3\fs24\lang1031\sl276\slmult1\sb0\sa200{\afs22\rtlch \ltrch\loch\fs22\lang7
}
\par \pard\plain \s0\nowidctlpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf0\hich\af3\langfe1031\dbch\af3\afs24\lang1031\loch\f3\fs24\lang1031\sl276\slmult1\qr\sb0\sa200{\afs22\rtlch \ltrch\loch\fs22\lang7
4.12.2018}
\par \pard\plain \s0\nowidctlpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf0\hich\af3\langfe1031\dbch\af3\afs24\lang1031\loch\f3\fs24\lang1031\sl276\slmult1\ql\sb0\sa200{\afs22\rtlch \ltrch\loch\fs22\lang7
finish with stateful languages:}
\par \pard\plain \s0\nowidctlpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf0\hich\af3\langfe1031\dbch\af3\afs24\lang1031\loch\f3\fs24\lang1031\sl276\slmult1\ql\sb0\sa200{\afs22\rtlch \ltrch\loch\fs22\lang7
state is not essential : these 2 code snippets do the same thing.}
\par \pard\plain \s0\nowidctlpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf0\hich\af3\langfe1031\dbch\af3\afs24\lang1031\loch\f3\fs24\lang1031\sl276\slmult1\ql\sb0\sa200{\afs22\rtlch \ltrch\loch\fs22\lang7
Box (=simple Datastructure) holds only one value, vairables hold value later on. Sewuencing = sequence of operations -> sequencing: changes made in 1}{{\*\updnprop5801}\up9\afs22\rtlch \ltrch\loch\fs22\lang7
st}{\afs22\rtlch \ltrch\loch\fs22\lang7
 expression should hold on in secound expression (sequential secound). This we do by using stor (environment which maps with the location ...)}
\par \pard\plain \s0\nowidctlpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf0\hich\af3\langfe1031\dbch\af3\afs24\lang1031\loch\f3\fs24\lang1031\sl276\slmult1\ql\sb0\sa200{\afs22\rtlch \ltrch\loch\fs22\lang7
Implementing simple thinsg becomes difficult: Change some variable in if condition -> see changes? Also suddenlty order in evaluation matters.}
\par \pard\plain \s0\nowidctlpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf0\hich\af3\langfe1031\dbch\af3\afs24\lang1031\loch\f3\fs24\lang1031\sl276\slmult1\ql\sb0\sa200{\afs22\rtlch \ltrch\loch\fs22\lang7
Variables and functions: at end do we ee changes made by f or not? It depends on interpreter semantic coz create new location in environmet with parameter pointing to new location. Create a completely new location in store where we don't modify the previous evaluation of v. This is called call-by-value. Call-by-Reference: instead of passing value and preparing new location for function, we pass reference to same location -> any change the function does is visible to outsinde of the environment. (Adds pointer to same reference.)}
\par \pard\plain \s0\nowidctlpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf0\hich\af3\langfe1031\dbch\af3\afs24\lang1031\loch\f3\fs24\lang1031\sl276\slmult1\ql\sb0\sa200{\afs22\rtlch \ltrch\loch\fs22\lang7
CBR: int a = 10; f(a); a ist eine kopie der realen value, ein verweis zum speicherort des \'93richtigen\'94 a. there is no way from insinde f to change the value of the very same address. When you pass a parammeter, CBR unterschied CBV unterscheidet sich, ob der Wert des Parameters (vom caller) ge\'e4ndert werden kann. Java hat nur CBV.}
\par \pard\plain \s0\nowidctlpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf0\hich\af3\langfe1031\dbch\af3\afs24\lang1031\loch\f3\fs24\lang1031\sl276\slmult1\ql\sb0\sa200{\afs22\rtlch \ltrch\loch\fs22\lang7
Environment vs store:}
\par \pard\plain \s0\nowidctlpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf0\hich\af3\langfe1031\dbch\af3\afs24\lang1031\loch\f3\fs24\lang1031\sl276\slmult1\ql\sb0\sa200{\afs22\rtlch \ltrch\loch\fs22\lang7
store is global record of all changes during the execution (lifetime of values)}
\par \pard\plain \s0\nowidctlpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf0\hich\af3\langfe1031\dbch\af3\afs24\lang1031\loch\f3\fs24\lang1031\sl276\slmult1\ql\sb0\sa200{\afs22\rtlch \ltrch\loch\fs22\lang7
environment caputres the lexical scope}
\par \pard\plain \s0\nowidctlpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf0\hich\af3\langfe1031\dbch\af3\afs24\lang1031\loch\f3\fs24\lang1031\sl276\slmult1\ql\sb0\sa200{\afs22\rtlch \ltrch\loch\fs22\lang7
}
\par \pard\plain \s0\nowidctlpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf0\hich\af3\langfe1031\dbch\af3\afs24\lang1031\loch\f3\fs24\lang1031\sl276\slmult1\ql\sb0\sa200{\afs22\rtlch \ltrch\loch\fs22\lang7
}
\par \pard\plain \s0\nowidctlpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf0\hich\af3\langfe1031\dbch\af3\afs24\lang1031\loch\f3\fs24\lang1031\sl276\slmult1\ql\sb0\sa200{\afs22\rtlch \ltrch\loch\fs22\lang7
V7 creating mutable boxes}
\par \pard\plain \s0\nowidctlpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf0\hich\af3\langfe1031\dbch\af3\afs24\lang1031\loch\f3\fs24\lang1031\sl276\slmult1\ql\sb0\sa200{\afs22\rtlch \ltrch\loch\fs22\lang7
when we interpret a value expression we can get a value and a update in the store. Every time we create a new box we neet a new free location in the menory. No operation to free the memory. At some point we will run out of memory. Heap overflow coz new box is created on heap and not on stack. Solution:}
\par \pard\plain \s0\nowidctlpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf0\hich\af3\langfe1031\dbch\af3\afs24\lang1031\loch\f3\fs24\lang1031\sl276\slmult1\ql\sb0\sa200{\afs22\rtlch \ltrch\loch\fs22\lang7
maual memory management: there is an operation that declares a chunk of memory as free so you can reuse it. }
\par \pard\plain \s0\nowidctlpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf0\hich\af3\langfe1031\dbch\af3\afs24\lang1031\loch\f3\fs24\lang1031\sl276\slmult1\ql\sb0\sa200{\afs22\rtlch \ltrch\loch\fs22\lang7
Automatic memory management: if nobody can reference a chunk of memory in the program, it will not be used anyway and can be free: folllwing two}
\par \pard\plain \s0\nowidctlpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf0\hich\af3\langfe1031\dbch\af3\afs24\lang1031\loch\f3\fs24\lang1031\sl276\slmult1\ql\sb0\sa200{\afs22\rtlch \ltrch\loch\fs22\lang7
reference counting: keep track of references of values. If no references point to a value, the value can be deleted. Issue quiz: circular dependencies both have pointer to each other. Solution: model it as a graph to notice circles. Also fragmentation}
\par \pard\plain \s0\nowidctlpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf0\hich\af3\langfe1031\dbch\af3\afs24\lang1031\loch\f3\fs24\lang1031\sl276\slmult1\ql\sb0\sa200{\afs22\rtlch \ltrch\loch\fs22\lang7
garbage collection: scan heap and remove unreferenced. Example links stack, rechts heap. Remove everything from the heap that the stack cannot reach. Quiz limitations: loading heap in chaches can become huge. Also worse fragmentation}
\par \pard\plain \s0\nowidctlpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf0\hich\af3\langfe1031\dbch\af3\afs24\lang1031\loch\f3\fs24\lang1031\sl276\slmult1\ql\sb0\sa200{\afs22\rtlch \ltrch\loch\fs22\lang7
(real-time == predictability)}
\par \pard\plain \s0\nowidctlpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf0\hich\af3\langfe1031\dbch\af3\afs24\lang1031\loch\f3\fs24\lang1031\sl276\slmult1\ql\sb0\sa200{\afs22\rtlch \ltrch\loch\fs22\lang7
box points to another region of the memory}
\par }